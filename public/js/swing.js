// Generated by CoffeeScript 1.6.2
(function() {
  var PositionModel, PositionObserver, PositionProcessor, PositionStruct, now, onMovement;

  now = function() {
    return new Date().getTime();
  };

  PositionProcessor = (function() {
    function PositionProcessor(model) {
      this.model = model;
      this.movementWindow = 1000;
      this.range = {
        "alpha": 360,
        "beta": 180,
        "gamma": 180
      };
    }

    PositionProcessor.prototype.extremes = function(history, attribute) {
      var dist, first, i, j, max, maxDistance, min, second, _i, _j, _len, _len1;

      if (history.length <= 0) {
        return {
          "min": -1,
          "max": -1,
          "distance": 0
        };
      }
      maxDistance = 0;
      first = history[0];
      second = history[0];
      for (_i = 0, _len = history.length; _i < _len; _i++) {
        i = history[_i];
        for (_j = 0, _len1 = history.length; _j < _len1; _j++) {
          j = history[_j];
          dist = this.distance(i[attribute], j[attribute], this.range[attribute]);
          if (dist > maxDistance) {
            maxDistance = dist;
            first = i;
            second = j;
          }
        }
      }
      min = Math.min(first[attribute], second[attribute]);
      max = Math.max(first[attribute], second[attribute]);
      return {
        "min": min,
        "max": max,
        "distance": maxDistance
      };
    };

    PositionProcessor.prototype.distance = function(n, k, range) {
      n = n % range;
      k = k % range;
      return Math.min(Math.abs(n - k), range - Math.abs(n - k));
    };

    PositionProcessor.prototype.hasMoved = function(lambda) {
      var alpha, beta, gamma, positions;

      positions = this.model.read(this.movementWindow);
      if (positions.length <= 0) {
        return false;
      }
      alpha = this.extremes(positions, "alpha");
      beta = this.extremes(positions, "beta");
      gamma = this.extremes(positions, "gamma");
      return alpha.distance > (7.0 / 8.0) * (this.range.alpha / 2.0) || beta.distance > (7.0 / 8.0) * (this.range.beta / 2.0) || gamma.distance > (7.0 / .0) * (this.range.gamma / 2.0);
    };

    return PositionProcessor;

  })();

  PositionObserver = (function() {
    function PositionObserver(model) {
      this.model = model;
    }

    PositionObserver.interval = 50;

    PositionObserver.prototype.getPosition = function() {
      var location;

      location = gyro.getOrientation();
      return new PositionStruct(now(), location.alpha, location.beta, location.gamma);
    };

    PositionObserver.prototype.track = function() {
      return this.model.write(this.getPosition());
    };

    return PositionObserver;

  })();

  PositionModel = (function() {
    function PositionModel() {
      this.history = [];
      this.maxHistory = 2500;
    }

    PositionModel.prototype.obliterate = function() {
      return this.history = [];
    };

    PositionModel.prototype.write = function(positionStruct) {
      this.history.push(positionStruct);
      return this.history = this.read(this.maxHistory);
    };

    PositionModel.prototype.read = function(age) {
      var position, time;

      time = now();
      return (function() {
        var _i, _len, _ref, _results;

        _ref = this.history;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          position = _ref[_i];
          if (time - position.age < age) {
            _results.push(position);
          }
        }
        return _results;
      }).call(this);
    };

    return PositionModel;

  })();

  PositionStruct = (function() {
    function PositionStruct(age, alpha, beta, gamma) {
      this.age = age;
      this.alpha = alpha;
      this.beta = beta;
      this.gamma = gamma;
    }

    return PositionStruct;

  })();

  onMovement = function(callback) {
    var model, observer, processor, wrapper;

    model = new PositionModel();
    observer = new PositionObserver(model);
    processor = new PositionProcessor(model);
    wrapper = function(observer, processor, callback) {
      var delay;

      delay = 50;
      observer.track();
      console.log(processor.model.history.length);
      if (processor.hasMoved()) {
        callback();
        model.obliterate();
        delay = 1000;
      }
      return setTimeout((function() {
        return wrapper(observer, processor, callback);
      }), delay);
    };
    return wrapper(observer, processor, callback);
  };

  onMovement(function() {
    $("body").append("moved <br />");
    if (window.navigator.vibrate) {
      return window.navigator.vibrate(500);
    }
  });

}).call(this);
