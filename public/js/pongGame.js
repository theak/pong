// Generated by CoffeeScript 1.3.3
var Action, Extrapolate, PongRound, PongState, Swing, pongRound,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

PongState = (function() {

  function PongState(timestamp, ballLocX, ballLocY, ballSpeedX, ballSpeedY) {
    this.timestamp = timestamp;
    this.ballLocX = ballLocX;
    this.ballLocY = ballLocY;
    this.ballSpeedX = ballSpeedX;
    this.ballSpeedY = ballSpeedY;
  }

  return PongState;

})();

Action = (function() {

  function Action(timestamp) {
    this.timestamp = timestamp;
  }

  Action.prototype.actOn = function(state) {};

  return Action;

})();

Extrapolate = (function(_super) {

  __extends(Extrapolate, _super);

  function Extrapolate() {
    return Extrapolate.__super__.constructor.apply(this, arguments);
  }

  Extrapolate.prototype.actOn = function(state) {
    var extrapolatedSpeedX, extrapolatedSpeedY, extrapolatedX, extrapolatedY, timeGap;
    timeGap = this.timestamp - state.timestamp;
    extrapolatedX = state.ballLocX + (timeGap * state.ballSpeedX);
    extrapolatedY = state.ballLocY + (timeGap * state.ballSpeedY);
    extrapolatedSpeedX = state.ballSpeedX;
    extrapolatedSpeedY = state.ballSpeedY;
    if (extrapolatedX > 1) {
      extrapolatedX = 2 - extrapolatedX;
      extrapolatedSpeedX *= -1;
    } else if (extrapolatedX < 0) {
      extrapolatedX *= -1;
      extrapolatedSpeedX *= -1;
    }
    return new PongState(this.timestamp, extrapolatedX, extrapolatedY, extrapolatedSpeedX, extrapolatedSpeedY);
  };

  return Extrapolate;

})(Action);

Swing = (function(_super) {

  __extends(Swing, _super);

  function Swing(timestamp, playerID, side, speed) {
    this.playerID = playerID;
    this.side = side;
    this.speed = speed;
    Swing.__super__.constructor.call(this, timestamp);
  }

  Swing.prototype.actOn = function(state) {
    var MAX_ANGLE, MAX_REACH, contactAngle, extrapolatedState, gap, reflectedBallSpeedX, reflectedBallSpeedY;
    MAX_REACH = 0.1;
    MAX_ANGLE = Math.PI / 4;
    extrapolatedState = new Extrapolate(this.timestamp).actOn(state);
    gap = extrapolatedState.ballLocY;
    if (this.playerID === 1) {
      gap = 1 - gap;
    }
    if (gap < 0 || gap > MAX_REACH) {
      return extrapolatedState;
    } else {
      contactAngle = MAX_ANGLE * gap / MAX_REACH;
      if (this.playerID === 1) {
        contactAngle += Math.PI;
      }
      if (this.side === "left") {
        contactAngle += Math.PI - (2 * contactAngle);
      }
      reflectedBallSpeedX = (extrapolatedState.ballSpeedX * Math.cos(2 * contactAngle)) + (extrapolatedState.ballSpeedY * Math.sin(2 * contactAngle));
      reflectedBallSpeedY = (extrapolatedState.ballSpeedX * Math.sin(2 * contactAngle)) + (extrapolatedState.ballSpeedY * -Math.cos(2 * contactAngle));
      if (reflectedBallSpeedX === 0 && reflectedBallSpeedY === 0) {
        reflectedBallSpeedY = 0.0005;
      }
      return new PongState(extrapolatedState.timestamp, extrapolatedState.ballLocX, extrapolatedState.ballLocY, reflectedBallSpeedX, reflectedBallSpeedY);
    }
  };

  return Swing;

})(Action);

PongRound = (function() {
  var actions, cachedStates;

  actions = [];

  cachedStates = [];

  function PongRound(startState) {
    this.startState = startState;
  }

  PongRound.prototype.addAction = function(newAction) {
    var newActionIndex;
    actions.push(newAction);
    actions.sort(function(a, b) {
      return a.timestamp - b.timestamp;
    });
    newActionIndex = actions.indexOf(newAction);
    return cachedStates = cachedStates.slice(0, newActionIndex);
  };

  PongRound.prototype.getStateAtTime = function(timestamp) {
    var actionIndex, mostRecentCachedIndex, mostRecentCachedState, mostRecentIndex, mostRecentState, nextAction, nextState, _i, _ref;
    mostRecentIndex = -1;
    for (actionIndex = _i = _ref = actions.length - 1; _ref <= -1 ? _i < -1 : _i > -1; actionIndex = _ref <= -1 ? ++_i : --_i) {
      if (actions[actionIndex].timestamp <= timestamp) {
        mostRecentIndex = actionIndex;
        break;
      }
    }
    mostRecentCachedIndex = Math.min(cachedStates.length - 1, mostRecentIndex);
    while (mostRecentCachedIndex < mostRecentIndex) {
      mostRecentCachedState = mostRecentCachedIndex >= 0 ? cachedStates[mostRecentCachedIndex] : this.startState;
      nextAction = actions[mostRecentCachedIndex + 1];
      nextState = nextAction.actOn(mostRecentCachedState);
      cachedStates[mostRecentCachedIndex + 1] = nextState;
      mostRecentCachedIndex += 1;
    }
    mostRecentState = mostRecentCachedIndex >= 0 ? cachedStates[mostRecentIndex] : this.startState;
    return new Extrapolate(timestamp).actOn(mostRecentState);
  };

  return PongRound;

})();

pongRound = new PongRound(new PongState(new Date().valueOf(), 0, 0, 0, 0));

window.onkeypress = function(event) {
  if (event.keyCode === 122) {
    return pongRound.addAction(new Swing(new Date().valueOf(), 0, "right", null));
  } else if (event.keyCode = 120) {
    return pongRound.addAction(new Swing(new Date().valueOf(), 1, "right", null));
  }
};

window.onload = function() {
  var COURT_SIZE, ball, court, renderingInterval;
  COURT_SIZE = 500;
  court = document.getElementById("court");
  court.style.position = "absolute";
  court.style.top = "0px";
  court.style.left = "0px";
  court.style.width = COURT_SIZE + "px";
  court.style.height = COURT_SIZE + "px";
  court.style.backgroundColor = "green";
  ball = document.getElementById("ball");
  ball.style.width = "10px";
  ball.style.height = "10px";
  ball.style.backgroundColor = "blue";
  ball.style.position = "absolute";
  return renderingInterval = setInterval(function() {
    var currentState, endTime, startTime;
    startTime = new Date().valueOf();
    currentState = pongRound.getStateAtTime(new Date().valueOf());
    ball.style.left = COURT_SIZE * currentState.ballLocX + "px";
    ball.style.bottom = COURT_SIZE * currentState.ballLocY + "px";
    endTime = new Date().valueOf();
    return console.log(currentState.ballLocX + ", " + currentState.ballLocY);
  }, 10);
};

window.stop = function() {
  return clearInterval(renderingInterval);
};
