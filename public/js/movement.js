// Generated by CoffeeScript 1.3.3
var PositionModel, PositionObserver, PositionProcessor, PositionStruct, now, onMovement, ranges;

now = function() {
  return new Date().getTime();
};

ranges = {
  "alpha": 360,
  "beta": 180,
  "gamma": 180
};

PositionProcessor = (function() {
  var movementWindow;

  movementWindow = 1000;

  function PositionProcessor(model) {
    this.model = model;
  }

  PositionProcessor.prototype.extremes = function(history, attribute) {
    var dist, first, i, j, max, maxDistance, min, second, _i, _j, _len, _len1;
    if (history.length <= 0) {
      return {
        "min": -1,
        "max": -1,
        "distance": 0
      };
    }
    maxDistance = 0;
    first = history[0];
    second = history[0];
    for (_i = 0, _len = history.length; _i < _len; _i++) {
      i = history[_i];
      for (_j = 0, _len1 = history.length; _j < _len1; _j++) {
        j = history[_j];
        dist = this.distance(i[attribute], j[attribute], ranges[attribute]);
        if (dist > maxDistance) {
          maxDistance = dist;
          first = i;
          second = j;
        }
      }
    }
    min = Math.min(first[attribute], second[attribute]);
    max = Math.max(first[attribute], second[attribute]);
    return {
      "min": min,
      "max": max,
      "distance": maxDistance
    };
  };

  PositionProcessor.prototype.distance = function(n, k, r) {
    n = n % r;
    k = k % r;
    return Math.min(Math.abs(n - k), r - Math.abs(n - k));
  };

  PositionProcessor.prototype.sign = function(first, second, range) {
    var d;
    d = this.distance(first, second, range);
    if (first - d === second || range + first - d === second) {
      return "pos";
    }
    if (first + d === second || first + d === second + range) {
      return "neg";
    }
    return "zero";
  };

  PositionProcessor.prototype.cardinality = function() {
    var first, i, position, positions, positionsToExamine, second, signCount, _i, _len, _ref;
    positions = this.model.read(movementWindow);
    if (positions.length <= 3) {
      return "rightToLeft";
    }
    signCount = {
      "zero": 0,
      "pos": 0,
      "neg": 0
    };
    positionsToExamine = positions.reverse();
    positionsToExamine = positionsToExamine.slice(0, 7);
    _ref = positionsToExamine.slice(0, (positionsToExamine.length - 3) + 1 || 9e9);
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      position = _ref[i];
      first = positions[i].alpha;
      second = positions[i + 1].alpha;
      signCount[this.sign(first, second, ranges["alpha"])] += 1;
    }
    if (signCount["pos"] > signCount["neg"]) {
      return "leftToRight";
    }
    return "rightToLeft";
  };

  PositionProcessor.prototype.hasMoved = function() {
    var alpha, beta, gamma, positions;
    positions = this.model.read(movementWindow);
    if (positions.length <= 3) {
      return false;
    }
    alpha = this.extremes(positions, "alpha");
    beta = this.extremes(positions, "beta");
    gamma = this.extremes(positions, "gamma");
    return alpha.distance > (6.0 / 8.0) * (ranges["alpha"] / 2.0) || beta.distance > (6.0 / 8.0) * (ranges["beta"] / 2.0) || gamma.distance > (6.0 / 8.0) * (ranges["gamma"] / 2.0);
  };

  return PositionProcessor;

})();

PositionObserver = (function() {

  function PositionObserver(model) {
    this.model = model;
  }

  PositionObserver.prototype.getPosition = function() {
    var position;
    position = gyro.getOrientation();
    return new PositionStruct(now(), Math.round(position.alpha, Math.round(position.beta + ranges["beta"] / 2), Math.round(position.gamma + ranges["gamma"] / 2)));
  };

  PositionObserver.prototype.track = function() {
    return this.model.write(this.getPosition());
  };

  return PositionObserver;

})();

PositionModel = (function() {
  var history, maxHistory;

  function PositionModel() {}

  history = [];

  maxHistory = 2500;

  PositionModel.prototype.obliterate = function() {
    return history = [];
  };

  PositionModel.prototype.write = function(positionStruct) {
    history.push(positionStruct);
    return history = this.read(maxHistory);
  };

  PositionModel.prototype.read = function(age) {
    var position, time;
    time = now();
    return (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = history.length; _i < _len; _i++) {
        position = history[_i];
        if (time - position.age < age) {
          _results.push(position);
        }
      }
      return _results;
    })();
  };

  return PositionModel;

})();

PositionStruct = (function() {

  function PositionStruct(age, alpha, beta, gamma) {
    this.age = age;
    this.alpha = alpha;
    this.beta = beta;
    this.gamma = gamma;
  }

  return PositionStruct;

})();

onMovement = function(callback) {
  var model, observer, processor, wrapper;
  model = new PositionModel();
  observer = new PositionObserver(model);
  processor = new PositionProcessor(model);
  wrapper = function(observer, processor, callback) {
    var delay;
    delay = 50;
    observer.track();
    if (processor.hasMoved()) {
      callback(processor.cardinality());
      model.obliterate();
      delay = 1000;
    }
    return setTimeout((function() {
      return wrapper(observer, processor, callback);
    }), delay);
  };
  return wrapper(observer, processor, callback);
};

/*
# #test code. 
onMovement((direction) ->
  $("body").append("moved" + direction + " <br />")
  if window.navigator.vibrate
    window.navigator.vibrate 500
 )
*/

